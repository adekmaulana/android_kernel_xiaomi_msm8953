#!/bin/sh
set -e

if ([ "$1" = "configure" ] && [ ! -e /etc/default/lxd-bridge ]) || \
        [ -n "${DEBCONF_RECONFIGURE}" ] || \
        ([ -n "${2}" ] && dpkg --compare-versions "${2}" lt "2.0.0~rc8-0ubuntu3~"); then
    . /usr/share/debconf/confmodule

    cidrmask() {
       set -- $(( 5 - ($1 / 8) )) 255 255 255 255 $(( (255 << (8 - ($1 % 8))) & 255 )) 0 0 0
       [ $1 -gt 1 ] && shift $1 || shift
       echo ${1-0}.${2-0}.${3-0}.${4-0}
    }

    dbget() {
        db_get ${1}
        echo ${RET}
    }

    # Get values
    bridge=$(dbget lxd/setup-bridge)
    bridge_name=$(dbget lxd/bridge-name)
    update_profile=$(dbget lxd/update-profile)
    ipv4_address=$(dbget lxd/bridge-ipv4-address)
    ipv4_cidr=$(dbget lxd/bridge-ipv4-netmask)
    ipv4_dhcp_first=$(dbget lxd/bridge-ipv4-dhcp-first)
    ipv4_dhcp_last=$(dbget lxd/bridge-ipv4-dhcp-last)
    ipv4_dhcp_leases=$(dbget lxd/bridge-ipv4-dhcp-leases)
    ipv4_nat=$(dbget lxd/bridge-ipv4-nat)
    ipv6_address=$(dbget lxd/bridge-ipv6-address)
    ipv6_cidr=$(dbget lxd/bridge-ipv6-netmask)
    ipv6_nat=$(dbget lxd/bridge-ipv6-nat)
    bridge_dnsmasq=$(dbget lxd/bridge-dnsmasq)
    bridge_domain=$(dbget lxd/bridge-domain)
    bridge_proxy=$(dbget lxd/bridge-http-proxy)

    # Generate the new config file
    [ -n "${ipv4_address}" ] && [ -n "${ipv4_cidr}" ] && ipv4_network="${ipv4_address}/${ipv4_cidr}"
    [ -n "${ipv4_cidr}" ] && ipv4_netmask=$(cidrmask ${ipv4_cidr})
    [ -n "${ipv4_dhcp_first}" ] && [ -n "${ipv4_dhcp_last}" ] && ipv4_dhcp_range="${ipv4_dhcp_first},${ipv4_dhcp_last}"
    [ -n "${ipv6_address}" ] && [ -n "${ipv6_cidr}" ] && ipv6_network="${ipv6_address}/${ipv6_cidr}"

    # Stop lxd-bridge unit (systemd specific)
    if [ -d /run/systemd/system ]; then
        deb-systemd-invoke stop lxd-bridge >/dev/null || true
    fi

    (
    cat << EOF
# WARNING: This file is generated by a debconf template!
# It is recommended to update it by using "dpkg-reconfigure -p medium lxd"

# Whether to setup a new bridge or use an existing one
USE_LXD_BRIDGE="${bridge}"

# Bridge name
# This is still used even if USE_LXD_BRIDGE is set to false
# set to an empty value to fully disable
LXD_BRIDGE="${bridge_name}"

# Update the "default" LXD profile
UPDATE_PROFILE="${update_profile}"

# Path to an extra dnsmasq configuration file
LXD_CONFILE="${bridge_dnsmasq}"

# DNS domain for the bridge
LXD_DOMAIN="${bridge_domain}"

# IPv4
## IPv4 address (e.g. 10.0.8.1)
LXD_IPV4_ADDR="${ipv4_address}"

## IPv4 netmask (e.g. 255.255.255.0)
LXD_IPV4_NETMASK="${ipv4_netmask}"

## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK="${ipv4_network}"

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE="${ipv4_dhcp_range}"

## IPv4 DHCP number of hosts (e.g. 250)
LXD_IPV4_DHCP_MAX="${ipv4_dhcp_leases}"

## NAT IPv4 traffic
LXD_IPV4_NAT="${ipv4_nat}"

# IPv6
## IPv6 address (e.g. 2001:470:b368:4242::1)
LXD_IPV6_ADDR="${ipv6_address}"

## IPv6 CIDR mask (e.g. 64)
LXD_IPV6_MASK="${ipv6_cidr}"

## IPv6 network (e.g. 2001:470:b368:4242::/64)
LXD_IPV6_NETWORK="${ipv6_network}"

## NAT IPv6 traffic
LXD_IPV6_NAT="${ipv6_nat}"

# Run a minimal HTTP PROXY server
LXD_IPV6_PROXY="${bridge_proxy}"
EOF
) > /etc/default/lxd-bridge
fi

# Automatically added by dh_apparmor
if [ "$1" = "configure" ]; then
    APP_PROFILE="/etc/apparmor.d/usr.lib.lxd.lxd-bridge-proxy"
    if [ -f "$APP_PROFILE" ]; then
        # Add the local/ include
        LOCAL_APP_PROFILE="/etc/apparmor.d/local/usr.lib.lxd.lxd-bridge-proxy"

        test -e "$LOCAL_APP_PROFILE" || {
            tmp=`mktemp`
        cat <<EOM > "$tmp"
# Site-specific additions and overrides for usr.lib.lxd.lxd-bridge-proxy.
# For more details, please see /etc/apparmor.d/local/README.
EOM
            mkdir `dirname "$LOCAL_APP_PROFILE"` 2>/dev/null || true
            mv -f "$tmp" "$LOCAL_APP_PROFILE"
            chmod 644 "$LOCAL_APP_PROFILE"
        }

        # Reload the profile, including any abstraction updates
        if aa-status --enabled 2>/dev/null; then
            apparmor_parser -r -T -W "$APP_PROFILE" || true
        fi
    fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable
# This will only remove masks created by d-s-h on package removal.
deb-systemd-helper unmask lxd.service >/dev/null || true

# was-enabled defaults to true, so new installations run enable.
if deb-systemd-helper --quiet was-enabled lxd.service; then
	# Enables the unit on first installation, creates new
	# symlinks on upgrades if the unit file has changed.
	deb-systemd-helper enable lxd.service >/dev/null || true
else
	# Update the statefile to add new symlinks (if any), which need to be
	# cleaned up on purge. Also remove old symlinks.
	deb-systemd-helper update-state lxd.service >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_systemd_enable
# This will only remove masks created by d-s-h on package removal.
deb-systemd-helper unmask lxd.socket >/dev/null || true

# was-enabled defaults to true, so new installations run enable.
if deb-systemd-helper --quiet was-enabled lxd.socket; then
	# Enables the unit on first installation, creates new
	# symlinks on upgrades if the unit file has changed.
	deb-systemd-helper enable lxd.socket >/dev/null || true
else
	# Update the statefile to add new symlinks (if any), which need to be
	# cleaned up on purge. Also remove old symlinks.
	deb-systemd-helper update-state lxd.socket >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_systemd_enable
# This will only remove masks created by d-s-h on package removal.
deb-systemd-helper unmask lxd-containers.service >/dev/null || true

# was-enabled defaults to true, so new installations run enable.
if deb-systemd-helper --quiet was-enabled lxd-containers.service; then
	# Enables the unit on first installation, creates new
	# symlinks on upgrades if the unit file has changed.
	deb-systemd-helper enable lxd-containers.service >/dev/null || true
else
	# Update the statefile to add new symlinks (if any), which need to be
	# cleaned up on purge. Also remove old symlinks.
	deb-systemd-helper update-state lxd-containers.service >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_installinit
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ]; then
	if [ -x "/etc/init.d/lxd" ]; then
		update-rc.d lxd defaults >/dev/null || exit $?
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_start
if [ -d /run/systemd/system ]; then
	systemctl --system daemon-reload >/dev/null || true
	deb-systemd-invoke start lxd-containers.service >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_installdeb
dpkg-maintscript-helper rm_conffile /etc/cron.hourly/lxd 2.0.0~rc2-0ubuntu3~ -- "$@"
# End automatically added section


# Manual init script handling
if [ -d /run/systemd/system ]; then
    systemctl --system daemon-reload >/dev/null || true
    deb-systemd-invoke start lxd.socket >/dev/null || true

    if ! systemctl -q is-active lxd.service; then
        deb-systemd-invoke restart lxd-containers.service >/dev/null || true
    fi
elif  [ -x "/etc/init.d/lxd" ] || [ -e "/etc/init/lxd.conf" ]; then
    invoke-rc.d lxd start || exit $?
fi

if [ -z "${2}" ]; then
    echo ""
    echo "The default LXD bridge, lxdbr0, comes unconfigured by default."
    echo "Only limited HTTP connectivity through a PROXY will be available."
    echo "To go through the initial LXD configuration, run: lxd init"
    echo ""
fi

# Fix a rare race condition where LXD is activated halfway through update
if [ -d /run/systemd/system ]; then
    if systemctl -q is-active lxd.service; then
        deb-systemd-invoke restart lxd.service >/dev/null || true
    fi
fi

exit 0
